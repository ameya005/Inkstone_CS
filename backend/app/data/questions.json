[
  {
    "id": "1",
    "title": "Two Sum",
    "difficulty": "easy",
    "category": "array",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "hints": [
      "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for simpler problems.",
      "So, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?"
    ],
    "companies": ["Amazon", "Google", "Microsoft", "Facebook"]
  },
  {
    "id": "2",
    "title": "Valid Parentheses",
    "difficulty": "easy",
    "category": "stack",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'."
    ],
    "hints": [
      "An interesting property about a valid parenthesis expression is that a sub-expression of a valid expression should also be a valid expression.",
      "What if whenever we encounter a matching pair of parenthesis in the expression, we simply remove it from the expression? This would keep on shortening the expression."
    ],
    "companies": ["Amazon", "Microsoft", "Google"]
  },
  {
    "id": "3",
    "title": "Reverse Linked List",
    "difficulty": "easy",
    "category": "linked_list",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]"
      },
      {
        "input": "head = []",
        "output": "[]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "hints": [
      "Think about how you would reverse a linked list on paper.",
      "You need to keep track of the previous node as you iterate through the list."
    ],
    "companies": ["Amazon", "Microsoft", "Apple", "Google"]
  },
  {
    "id": "4",
    "title": "Maximum Subarray",
    "difficulty": "medium",
    "category": "dynamic_programming",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "hints": [
      "Try using dynamic programming. Keep track of the maximum sum ending at each position.",
      "Kadane's algorithm is a classic approach for this problem."
    ],
    "companies": ["Amazon", "Microsoft", "Google", "Apple"]
  },
  {
    "id": "5",
    "title": "Binary Tree Inorder Traversal",
    "difficulty": "easy",
    "category": "tree",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\nInorder traversal visits nodes in this order: left subtree, root, right subtree.",
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]"
      },
      {
        "input": "root = []",
        "output": "[]"
      },
      {
        "input": "root = [1]",
        "output": "[1]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "hints": [
      "Try both recursive and iterative approaches.",
      "For iterative approach, use a stack to simulate the recursion."
    ],
    "companies": ["Microsoft", "Amazon", "Google"]
  },
  {
    "id": "6",
    "title": "Merge Two Sorted Lists",
    "difficulty": "easy",
    "category": "linked_list",
    "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "hints": [
      "Use a dummy head to simplify the logic.",
      "Compare the values and attach the smaller node to your result."
    ],
    "companies": ["Amazon", "Microsoft", "Apple", "Google"]
  },
  {
    "id": "7",
    "title": "Contains Duplicate",
    "difficulty": "easy",
    "category": "array",
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false"
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Think about different data structures that can help you track seen elements.",
      "What's the time complexity of different approaches?"
    ],
    "companies": ["Amazon", "Google", "Microsoft"]
  },
  {
    "id": "8",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "easy",
    "category": "array",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "hints": [
      "Think about tracking the minimum price seen so far.",
      "For each day, calculate the profit if you sold on that day."
    ],
    "companies": ["Amazon", "Microsoft", "Google", "Apple"]
  },
  {
    "id": "9",
    "title": "Valid Anagram",
    "difficulty": "easy",
    "category": "string",
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true"
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase English letters."
    ],
    "hints": [
      "Think about counting character frequencies.",
      "What different approaches can you use? Sorting vs counting?"
    ],
    "companies": ["Amazon", "Google", "Microsoft"]
  },
  {
    "id": "10",
    "title": "Group Anagrams",
    "difficulty": "medium",
    "category": "string",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]"
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]"
      }
    ],
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "hints": [
      "Think about what makes two strings anagrams of each other.",
      "How can you use a hash map to group anagrams efficiently?"
    ],
    "companies": ["Amazon", "Microsoft", "Google", "Apple"]
  },
  {
    "id": "11",
    "title": "Top K Frequent Elements",
    "difficulty": "medium",
    "category": "heap",
    "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]"
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is in the range [1, the number of unique elements in the array].",
      "It is guaranteed that the answer is unique."
    ],
    "hints": [
      "Think about counting frequencies first.",
      "Consider using a heap or bucket sort approach."
    ],
    "companies": ["Amazon", "Google", "Microsoft", "Facebook"]
  },
  {
    "id": "12",
    "title": "Product of Array Except Self",
    "difficulty": "medium",
    "category": "array",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]"
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ],
    "hints": [
      "Think about calculating left and right products separately.",
      "Can you do this in a single pass with constant extra space?"
    ],
    "companies": ["Amazon", "Microsoft", "Google", "Apple"]
  }
]